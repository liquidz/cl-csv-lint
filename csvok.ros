#!/bin/sh
#|-*- mode:lisp -*-|#
#| <Put a one-line description here>
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  (ql:quickload '(cl-ppcre
                   cl-csv
                   yason
                   unix-options)
                :silent t))

(defpackage :ros.script.csvok
  (:use :cl
        :unix-options))
(in-package :ros.script.csvok)

(defun read-json (json-file)
  (with-open-file (stream json-file :if-does-not-exist nil)
    (when stream
      (yason:parse stream))))

(defun read-csv (csv-file &key (skip-header nil))
  (let ((csv (cl-csv:read-csv csv-file)))
    (if skip-header
      (cdr csv)
      csv)))

(defun validate-csv-column (rule-hash csv-value)
  (let ((name    (gethash "name" rule-hash))
        (pattern (gethash "pattern" rule-hash)))
    (unless (ppcre:scan pattern csv-value)
      (format () "~A error: rule[~A] value[~A]"
               name pattern csv-value))))

(defun validate-csv-row (rule-hash-list target-csv-row)
  (if (not (= (length rule-hash-list) (length target-csv-row)))
    (list (format () "invalid length: expected[~A] actual[~A]"
                  (length rule-hash-list) (length target-csv-row)))
    (remove-if #'not
               (mapcar #'validate-csv-column
                       rule-hash-list
                       target-csv-row))))

(defun validate-csv (rule csv)
  (reduce (lambda (res row)
            (append res (validate-csv-row rule row)))
          csv :initial-value ()))

(defun main (&rest argv)
  (with-cli-options
    (argv t) (skip-header &parameters rule-file)

    (unless rule-file
      (format t "rule-file must be set~%")
      (sb-ext:exit :code 1))

    (unless (first free)
      (print "csv-file must be set")
      (sb-ext:exit :code 1))

    (let ((rule (read-json rule-file))
          (csv  (read-csv (first free) :skip-header skip-header)))
      (let ((result (validate-csv rule csv)))
        (if result
          (format t "~A~%" result)
          (format t "valid"))))))
      

;;; vim: set ft=lisp lisp:
